<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js";
import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, query, orderBy, getDocs, writeBatch, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-firestore.js";
import { getAuth, signInWithEmailAndPassword, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js";

const firebaseConfig = {
  apiKey: "AIzaSyDNk1We9du5BJyrgGbQrkqd7tSDscneIOA",
  authDomain: "gold-11fa4.firebaseapp.com",
  databaseURL: "https://gold-11fa4-default-rtdb.firebaseio.com",
  projectId: "gold-11fa4",
  storageBucket: "gold-11fa4.firebasestorage.app",
  messagingSenderId: "226774330161",
  appId: "1:226774330161:web:d1e1c93ade5dcea31d5e10",
  measurementId: "G-7MLLBN1YZ4"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const auth = getAuth(app);

const balanceDisplay = document.getElementById("balanceDisplay");
const manualAmount = document.getElementById("manualAmount");
const addBtn = document.getElementById("addBtn");
const historyList = document.getElementById("historyList");

let rate = 15000;
let lastBalance = 0;
let holidays = ["2025-01-01","2025-03-08","2025-03-21","2025-03-22","2025-03-23","2025-05-01","2025-05-07","2025-05-09","2025-07-06","2025-08-30","2025-12-16","2025-12-17"];

const emailInput = document.getElementById("email");
const passwordInput = document.getElementById("password");
const loginBtnEl = document.getElementById("loginBtn");
const logoutBtnEl = document.getElementById("logoutBtn");
const authStatus = document.getElementById("authStatus");
const toggleAuth = document.getElementById("toggleAuth");
const authForm = document.getElementById("authForm");

// UI auth toggle
toggleAuth.onclick = ()=>{ authForm.classList.toggle("show"); }
loginBtnEl.onclick = async () => { try { await signInWithEmailAndPassword(auth,emailInput.value,passwordInput.value);} catch(e){ alert("Ошибка: "+e.message);} };
logoutBtnEl.onclick = async()=>{await signOut(auth);}
onAuthStateChanged(auth,user=>{
  if(user){
    authStatus.textContent="Вы вошли как "+user.email;
    loginBtnEl.style.display="none"; logoutBtnEl.style.display="inline-block";
    emailInput.style.display=passwordInput.style.display="none";
    authForm.classList.remove("show");
    toggleAuth.textContent="Пользователь авторизован";
    enableEditing(true);
  } else {
    authStatus.textContent="Не авторизованы";
    loginBtnEl.style.display="inline-block"; logoutBtnEl.style.display="none";
    emailInput.style.display=passwordInput.style.display="inline-block";
    toggleAuth.textContent="Авторизация";
    enableEditing(false);
  }
});
function enableEditing(enabled){ manualAmount.disabled = !enabled; addBtn.disabled = !enabled; }

// Document & entries subcollection (explicit, reliable)
const balanceDocRef = doc(db,"salaryData","balance");
// entries will be a subcollection under salaryData/balance
const entriesColRef = collection(balanceDocRef, "entries");

// --- Более надежная анимация изменения баланса + всплывающая цифра ---
function animateBalanceChange(newBalance, prevBalance, changeAmount = 0){
  // numeric animation using requestAnimationFrame for smoothness
  const duration = 400;
  const start = performance.now();
  const from = Number(prevBalance) || 0;
  const to = Number(newBalance) || 0;
  balanceDisplay.style.color = (to - from >= 0) ? "#2e7d32" : "#c62828";

  function step(now){
    const t = Math.min(1, (now - start) / duration);
    // easeOutCubic
    const eased = 1 - Math.pow(1 - t, 3);
    const val = Math.round(from + (to - from) * eased);
    balanceDisplay.textContent = val.toLocaleString('ru-RU');
    if(t < 1) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);

  if(changeAmount !== 0){
    const rect = balanceDisplay.getBoundingClientRect();
    const anim = document.createElement("div");
    anim.className = "balance-popup";
    anim.textContent = (changeAmount > 0 ? "+" : "-") + Math.abs(changeAmount).toLocaleString('ru-RU');

    // styling via inline to ensure it works without external CSS changes
    Object.assign(anim.style, {
      position: "absolute",
      left: (rect.left + window.scrollX + rect.width / 2) + "px",
      top: (rect.top + window.scrollY - 10) + "px",
      transform: "translate(-50%, 0)",
      fontWeight: "700",
      fontSize: "1.2em",
      color: changeAmount > 0 ? "#2e7d32" : "#c62828",
      pointerEvents: "none",
      transition: "transform 900ms cubic-bezier(.2,.8,.2,1), opacity 900ms ease-out",
      opacity: "1",
      zIndex: 9999,
      willChange: "transform, opacity"
    });

    document.body.appendChild(anim);
    // trigger transition
    requestAnimationFrame(()=>{
      anim.style.transform = "translate(-50%, -48px)";
      anim.style.opacity = "0";
    });
    // remove after animation
    setTimeout(()=>anim.remove(), 1000);
  }
}

// --- История: чтение и рендеринг ---
async function updateHistory(){
  try{
    const q = query(entriesColRef, orderBy("date","desc"));
    const snapshot = await getDocs(q);
    if(snapshot.empty){ historyList.innerHTML="Нет записей"; return; }
    historyList.innerHTML = "";
    snapshot.forEach(d=>{
      const data = d.data();
      // date can be Firestore Timestamp (serverTimestamp) or ISO string
      let dateStr = "—";
      if(data.date && typeof data.date.toDate === "function"){ dateStr = data.date.toDate().toLocaleString(); }
      else if(data.date){ dateStr = new Date(data.date).toLocaleString(); }

      const amount = (typeof data.amount === "number") ? data.amount.toLocaleString('ru-RU') : String(data.amount);
      const sign = data.amount >= 0 ? "+" : "-";
      const div = document.createElement("div");
      div.className = "history-item";
      div.innerHTML = `<div class="history-date">${dateStr}</div>
                       <div class="history-amount" style="color:${data.amount>=0?"#2e7d32":"#c62828"}">${sign}${amount}</div>`;
      historyList.appendChild(div);
    });
  }catch(e){
    console.error("Ошибка получения истории:", e);
    historyList.innerHTML = "Нет записей";
  }
}

// --- Atomically update balance + add history entry (reliable) ---
async function commitBalanceChange(amount){
  // Use a batched write for atomicity: update balance doc and create a new entry doc in the subcollection
  try{
    const batch = writeBatch(db);
    const balSnap = await getDoc(balanceDocRef);
    let current = balSnap && balSnap.exists() && typeof balSnap.data().balance === "number" ? balSnap.data().balance : lastBalance || 0;
    const newBalance = current + amount;

    batch.set(balanceDocRef, { balance: newBalance });
    // create a new entry doc ref (auto id) inside entries subcollection
    const newEntryRef = doc(entriesColRef);
    batch.set(newEntryRef, { date: serverTimestamp(), amount: amount });

    await batch.commit();
    return newBalance;
  }catch(err){
    console.warn("Batch commit failed, falling back to sequential writes:", err);
    // fallback: try sequential writes so UI still updates
    try{
      const balSnap = await getDoc(balanceDocRef);
      let current = balSnap && balSnap.exists() && typeof balSnap.data().balance === "number" ? balSnap.data().balance : lastBalance || 0;
      const newBalance = current + amount;
      await setDoc(balanceDocRef,{balance:newBalance});
      // try add entry as document with serverTimestamp fallback to ISO if serverTimestamp blocked
      try{
        const newEntryRef = doc(entriesColRef);
        await setDoc(newEntryRef, { date: new Date().toISOString(), amount });
      }catch(e2){
        console.warn("Не удалось добавить запись в подколлекцию через setDoc:", e2);
        // last resort: try addDoc (if allowed)
        try{
          await addDoc(entriesColRef, { date: new Date().toISOString(), amount });
        }catch(e3){
          console.error("Не удалось добавить запись в историю:", e3);
        }
      }
      return newBalance;
    }catch(finalErr){
      console.error("Полный сбой записи баланса:", finalErr);
      throw finalErr;
    }
  }
}

// --- Инициализация баланса ---
async function initBalance(){
  try{
    const docSnap = await getDoc(balanceDocRef);
    if(docSnap && docSnap.exists()){
      const data = docSnap.data();
      lastBalance = (typeof data.balance === "number") ? data.balance : 0;
    } else {
      // local default
      lastBalance = 161000;
      try{ await setDoc(balanceDocRef,{balance:lastBalance}); }catch(e){ console.warn("Не удалось записать начальную сумму в Firestore:", e); }
    }
    balanceDisplay.textContent = lastBalance.toLocaleString('ru-RU');
    updateHistory();

    // realtime sync for balance
    onSnapshot(balanceDocRef,(snapshotDoc)=>{
      if(snapshotDoc && snapshotDoc.exists()){
        let newBalance = snapshotDoc.data().balance;
        animateBalanceChange(newBalance,lastBalance,newBalance-lastBalance);
        lastBalance = newBalance;
      }
      updateHistory();
    }, (err)=>{ console.error("onSnapshot error:", err); });

  }catch(e){
    console.error("Ошибка инициализации баланса:", e);
    lastBalance = lastBalance || 161000;
    balanceDisplay.textContent = lastBalance.toLocaleString('ru-RU');
    historyList.innerHTML = "Нет записей";
  }
}

// --- Ручное добавление: теперь использует commitBalanceChange для атомарности ---
addBtn.onclick = async ()=>{
  try{
    let value = parseFloat(manualAmount.value);
    if(isNaN(value)) return alert("Введите число!");
    // commit atomically
    const newBalance = await commitBalanceChange(value);
    // animate locally (in case onSnapshot lags)
    animateBalanceChange(newBalance, lastBalance, value);
    lastBalance = newBalance;
    manualAmount.value = "";
    // ensure history refresh (onSnapshot or updateHistory)
    updateHistory();
  }catch(e){
    console.error("Ошибка при ручном добавлении:", e);
    alert("Не удалось сохранить изменение. Смотрите консоль.");
  }
};

// --- Ежедневное добавление ставки (использует commitBalanceChange) ---
async function addDailyRate(){
  try{
    let todayStr = new Date().toISOString().split("T")[0];
    let todayRate = holidays.includes(todayStr) ? 20000 : rate;
    const newBalance = await commitBalanceChange(todayRate);
    animateBalanceChange(newBalance, lastBalance, todayRate);
    lastBalance = newBalance;
    updateHistory();
  }catch(e){
    console.error("Ошибка при добавлении ежедневной ставки:", e);
  }
}

function scheduleDailyAddition(){
  const now = new Date();
  const next22 = new Date();
  next22.setHours(22,0,0,0);
  if(now>next22) next22.setDate(next22.getDate()+1);
  const msUntil22 = next22 - now;
  setTimeout(async ()=>{
    await addDailyRate();
    scheduleDailyAddition();
  }, msUntil22);
}

initBalance();
scheduleDailyAddition();
</script>
