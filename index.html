<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>Автоподсчёт зарплаты</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
body { font-family: Arial; max-width: 800px; margin: auto; padding: 20px; }
input, button { padding: 5px; margin: 5px 0; width: 100%; box-sizing: border-box; }
#history { margin-top: 20px; }
.history-item { display: flex; justify-content: space-between; align-items: center; margin: 5px 0; gap: 8px; }
.history-left { flex: 1; }
.history-actions { display: flex; gap: 6px; }
.small-btn { padding: 4px 8px; width: auto; }
canvas { margin-top: 20px; max-width: 100%; }
.auth { display:flex; gap:8px; align-items:center; margin-bottom:10px; }
</style>
</head>
<body>

<h2>Учёт зарплаты</h2>

<div class="auth">
  <button id="loginBtn">Войти (Google)</button>
  <button id="logoutBtn" style="display:none;">Выйти</button>
  <div id="userInfo" style="margin-left:8px"></div>
  <button id="migrateBtn" title="Перенести локальные транзакции на Firebase">Мигрировать localStorage → Firebase</button>
</div>

<label>Дата транзакции:</label>
<input type="date" id="transDate">

<label>Сумма (положительное число — аванс, отрицательное — выплата):</label>
<input type="number" id="change">

<div style="display:flex; gap:8px;">
  <button id="saveBtn" onclick="addOrSaveTransaction()">Добавить транзакцию</button>
  <button id="cancelBtn" onclick="cancelEdit()" style="display:none; width: 150px;">Отменить</button>
</div>

<div id="history"></div>
<div id="result"></div>

<canvas id="salaryChart" width="700" height="300"></canvas>

<script type="module">
/*
  Firebase integration (best-practice per-user storage):
  - Скопируйте firebaseConfig из вашей консоли Firebase и вставьте ниже.
  - Данные хранятся в коллекции users/{uid}/transactions для приватности.
  - Перед деплоем настройте Firestore security rules так, чтобы пользователи могли
    читать/писать только свои документы (пример правил в комментарии ниже).
*/

import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js";
import {
  getFirestore, collection, addDoc, updateDoc, deleteDoc, doc,
  onSnapshot, query, orderBy, serverTimestamp, getDocs
} from "https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore.js";
import {
  getAuth, signInWithPopup, GoogleAuthProvider, onAuthStateChanged, signOut
} from "https://www.gstatic.com/firebasejs/9.22.1/firebase-auth.js";

// TODO: вставьте сюда конфиг вашего Firebase проекта
const firebaseConfig = {
  apiKey: "YOUR_API_KEY",
  authDomain: "YOUR_AUTH_DOMAIN",
  projectId: "YOUR_PROJECT_ID",
  // ... остальные поля
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const auth = getAuth(app);
const provider = new GoogleAuthProvider();

// UI elements
const loginBtn = document.getElementById('loginBtn');
const logoutBtn = document.getElementById('logoutBtn');
const userInfo = document.getElementById('userInfo');
const migrateBtn = document.getElementById('migrateBtn');

loginBtn.addEventListener('click', async () => {
  try {
    await signInWithPopup(auth, provider);
  } catch (e) {
    console.error('Ошибка входа:', e);
    alert('Не удалось войти: ' + e.message);
  }
});
logoutBtn.addEventListener('click', () => signOut(auth));
migrateBtn.addEventListener('click', migrateLocalToFirestore);

// app state
let transactions = []; // {id, date, amount}
let editingId = null;  // id документа в Firestore (или temporary id for local fallback)
let unsubscribeSnapshot = null;
let currentUid = null;

// default accounting params
let rate = 15000;
let startDate = new Date("2025-10-23");

// Firestore rules suggestion (пример, добавьте в Firebase консоль -> Rules):
/*
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /users/{userId}/transactions/{docId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
  }
}
*/

// helper: get user's transactions collection reference
function userTransactionsCollection(uid) {
  return collection(db, `users/${uid}/transactions`);
}

// Subscribe to user's transactions when logged in (or to empty state when not)
function subscribeToUserTransactions(uid) {
  if (unsubscribeSnapshot) unsubscribeSnapshot();

  if (!uid) {
    // Not logged in: load localStorage data as fallback
    const local = JSON.parse(localStorage.getItem('transactions')) || [];
    transactions = local.map((t, idx) => ({ id: t.id || `local-${idx}-${Date.now()}`, date: t.date, amount: Number(t.amount) }));
    updateDisplay();
    return;
  }

  currentUid = uid;
  const q = query(userTransactionsCollection(uid), orderBy('date', 'asc'), orderBy('createdAt', 'asc'));
  unsubscribeSnapshot = onSnapshot(q, snapshot => {
    transactions = snapshot.docs.map(d => {
      const data = d.data();
      return { id: d.id, date: data.date, amount: Number(data.amount) };
    });
    updateDisplay();
  }, err => {
    console.error('Ошибка подписки на Firestore:', err);
    // fallback to localStorage on error
    const local = JSON.parse(localStorage.getItem('transactions')) || [];
    transactions = local.map((t, idx) => ({ id: t.id || `local-${idx}-${Date.now()}`, date: t.date, amount: Number(t.amount) }));
    updateDisplay();
  });
}

// Auth state changes
onAuthStateChanged(auth, user => {
  if (user) {
    userInfo.textContent = user.displayName || user.email;
    loginBtn.style.display = 'none';
    logoutBtn.style.display = 'inline-block';
    subscribeToUserTransactions(user.uid);
  } else {
    userInfo.textContent = 'Аноним';
    loginBtn.style.display = 'inline-block';
    logoutBtn.style.display = 'none';
    currentUid = null;
    subscribeToUserTransactions(null);
  }
});

// ----- Balance calculation (unchanged) -----
function calculateBalance() {
    let today = new Date();
    let daysWorked = Math.floor((today - startDate)/(1000*60*60*24)) + 1;
    if (daysWorked < 1) daysWorked = 1;
    let balanceByDay = [];
    let total = 0;

    for (let i=0; i<daysWorked; i++) {
        total += rate;
        let currentDate = new Date(startDate);
        currentDate.setDate(currentDate.getDate() + i);
        transactions.forEach(t => {
            let tDate = new Date(t.date);
            if (tDate.toDateString() === currentDate.toDateString()) total -= t.amount;
        });
        balanceByDay.push({date: new Date(currentDate), balance: total});
    }
    return balanceByDay;
}

// ----- Add or save transaction -----
async function addOrSaveTransaction() {
    const dateInput = document.getElementById('transDate').value;
    const amount = parseFloat(document.getElementById('change').value);
    if (!dateInput || isNaN(amount)) return alert("Заполните дату и сумму.");

    try {
      if (currentUid) {
        // operate on Firestore: create or update in users/{uid}/transactions
        if (editingId) {
          const dRef = doc(db, `users/${currentUid}/transactions`, editingId);
          await updateDoc(dRef, { date: dateInput, amount: amount });
          editingId = null;
        } else {
          await addDoc(userTransactionsCollection(currentUid), { date: dateInput, amount: amount, createdAt: serverTimestamp() });
        }
      } else {
        // not authenticated: operate on localStorage fallback
        if (editingId) {
          const idx = transactions.findIndex(t => t.id === editingId);
          if (idx >= 0) { transactions[idx].date = dateInput; transactions[idx].amount = amount; }
          editingId = null;
        } else {
          const id = 'local-' + Date.now();
          transactions.push({ id, date: dateInput, amount });
        }
        localStorage.setItem('transactions', JSON.stringify(transactions.map(t => ({ id: t.id, date: t.date, amount: t.amount }))));
        updateDisplay();
      }
    } catch (e) {
      console.error('Ошибка сохранения транзакции:', e);
      alert('Не удалось сохранить: ' + e.message);
    }

    clearForm();
}

// ----- Start edit -----
function startEdit(i) {
    const t = transactions[i];
    document.getElementById('transDate').value = t.date;
    document.getElementById('change').value = t.amount;
    editingId = t.id;
    document.getElementById('saveBtn').textContent = "Сохранить изменение";
    document.getElementById('cancelBtn').style.display = "inline-block";
}

// ----- Cancel edit -----
function cancelEdit() {
    editingId = null;
    clearForm();
    document.getElementById('saveBtn').textContent = "Добавить транзакцию";
    document.getElementById('cancelBtn').style.display = "none";
}

// ----- Delete transaction -----
async function deleteTransaction(i) {
    if (!confirm("Удалить эту транзакцию?")) return;
    const id = transactions[i].id;
    try {
      if (currentUid && !id.startsWith('local-')) {
        await deleteDoc(doc(db, `users/${currentUid}/transactions`, id));
      } else {
        // local fallback
        transactions.splice(i,1);
        localStorage.setItem('transactions', JSON.stringify(transactions.map(t => ({ id: t.id, date: t.date, amount: t.amount }))));
        updateDisplay();
      }
      if (editingId === id) cancelEdit();
    } catch (e) {
      console.error('Ошибка удаления транзакции:', e);
      alert('Не удалось удалить: ' + e.message);
    }
}

// ----- Clear form -----
function clearForm() {
    document.getElementById('transDate').value = "";
    document.getElementById('change').value = "";
    document.getElementById('saveBtn').textContent = "Добавить транзакцию";
    document.getElementById('cancelBtn').style.display = "none";
}

// ----- Display and chart (unchanged logic) -----
function updateDisplay() {
    let historyHTML = "<h3>История транзакций:</h3>";
    if (transactions.length === 0) {
        historyHTML += "<div>Транзакций нет</div>";
    } else {
        transactions.forEach((t,i)=>{
            const sign = t.amount > 0 ? '+' : '-';
            const abs = Math.abs(t.amount).toLocaleString('ru-RU');
            historyHTML += `<div class="history-item">
                <div class="history-left">${t.date}: ${sign}${abs}</div>
                <div class="history-actions">
                  <button class="small-btn" onclick="startEdit(${i})">Редактировать</button>
                  <button class="small-btn" onclick="deleteTransaction(${i})">Удалить</button>
                </div>
            </div>`;
        });
    }
    document.getElementById('history').innerHTML = historyHTML;

    let balanceByDay = calculateBalance();
    let totalBalance = balanceByDay[balanceByDay.length-1]?.balance || 0;
    document.getElementById('result').innerHTML = `<h3>Итог: ${totalBalance.toLocaleString('ru-RU')} тенге</h3>`;

    drawChart(balanceByDay);
}

function drawChart(balanceByDay) {
    const ctx = document.getElementById('salaryChart').getContext('2d');
    if(window.salaryChartInstance) window.salaryChartInstance.destroy();
    window.salaryChartInstance = new Chart(ctx,{ 
        type:'line',
        data:{
            labels: balanceByDay.map(b=>b.date.toISOString().split('T')[0]),
            datasets:[{
                label:'Баланс',
                data: balanceByDay.map(b=>b.balance),
                borderColor:'green',
                fill:false,
                tension:0.3
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false
        }
    });
}

// ----- Migration: push existing localStorage transactions into user's Firestore collection -----
async function migrateLocalToFirestore() {
  if (!currentUid) return alert('Чтобы мигрировать, войдите в аккаунт Google.');
  if (!confirm('Перенести транзакции из localStorage в ваш Firestore (users/{uid}/transactions)? Дубликаты не проверяются.')) return;
  const local = JSON.parse(localStorage.getItem('transactions')) || [];
  if (local.length === 0) return alert('В localStorage нет транзакций.');
  try {
    for (const t of local) {
      // сохраняем как документ с createdAt
      await addDoc(userTransactionsCollection(currentUid), { date: t.date, amount: Number(t.amount), createdAt: serverTimestamp() });
    }
    alert('Миграция завершена. При желании очистите localStorage вручную.');
  } catch (e) {
    console.error('Ошибка миграции:', e);
    alert('Ошибка миграции: ' + e.message);
  }
}

// expose functions for inline handlers
window.addOrSaveTransaction = addOrSaveTransaction;
window.cancelEdit = cancelEdit;
window.startEdit = startEdit;
window.deleteTransaction = deleteTransaction;

// initial display (will be updated by subscribeToUserTransactions via auth state)
updateDisplay();

</script>
</body>
</html>